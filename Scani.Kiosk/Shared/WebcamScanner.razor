@inject IJSRuntime JsRuntime

<button class="btn btn-dark" @onclick="_ => _isModalVisable = true" style="position: relative;">
    <img src="/assets/images/lens.svg" style="width: 50px" />
    @if (_showHadScanResultFlash)
    {
        <div class="spinner-grow text-success" role="status" style="position: absolute; left: calc(50% - 0.5 * 2rem); top: calc(50% - 0.5 * 2rem);">
          <span class="visually-hidden">Scaned!</span>
        </div>
    }
    else if (_showHadScanErrorFlash)
    {
        <div class="spinner-grow text-danger" role="status" style="position: absolute; left: calc(50% - 0.5 * 2rem); top: calc(50% - 0.5 * 2rem);">
          <span class="visually-hidden">Errored!</span>
        </div>
    }
    else if (_selectedScanningMediaDevice != null)
    {
        <div class="spinner-grow text-primary" role="status" style="position: absolute; left: calc(50% - 0.5 * 2rem); top: calc(50% - 0.5 * 2rem); background-color: rgba(13, 110, 253, 0.3);">
          <span class="visually-hidden">Scanning...</span>
        </div>
    }
</button>

<Modal
    IsVisable="_isModalVisable"
    OnModalDismissedFromJs="() => _isModalVisable = false"
    BodyStyle="display: flex; flex-direction: column; justify-items: center; align-items: center; gap: 1em;"
>
    <Body>
        @if (_ZXingMediaDevices != null)
        {
            <div class="dropdown">
                <div
                    class="btn btn-primary dropdown-toggle"
                    href="#"
                    role="button"
                    id="mediaDeviceDropdownButton"
                    data-bs-toggle="dropdown"
                    aria-expanded="false"
                >
                    @if (_selectedScanningMediaDevice == null)
                    {
                        @("No device selected");
                    }
                    else
                    {
                        @(_selectedScanningMediaDevice.Label);
                    }
                </div>
                <ul class="dropdown-menu" aria-labelledby="mediaDeviceDropdownButton">
                    @foreach (var mediaDevice in _ZXingMediaDevices)
                    {
                        <li @key="mediaDevice.DeviceId">
                            <a class="dropdown-item" href="#" @onclick="e => EnableScanningWithMediaDevice(mediaDevice)" @onclick:preventDefault>
                                @mediaDevice.Label
                            </a>
                        </li>
                    }
                    <li @key="@("_disable")">
                        <a class="dropdown-item" href="#" @onclick="e => DisableScanning()" @onclick:preventDefault>
                            Disable
                        </a>
                    </li>
                </ul>
            </div>
        }

        @if (_ZXingMediaDevices == null)
        {
            <p>There are no video devices detected so webcam scanning will not work.</p>
        }
        else if (_selectedScanningMediaDevice == null)
        {
            <p>Video scanning has been disabled, select a video device from the above dropdown list to enable video scanning.</p>
        }
        else
        {
            <video @ref="_webcamPreviewVideoElement" width="300" height="200" style="padding: 1em;"></video>   
        }
    </Body>
    <Footer>
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
    </Footer>
</Modal>

@code {
    [Parameter] public EventCallback<string> OnZXingResult { get; set; }
    private IReadOnlyList<MediaDeviceInfo>? _ZXingMediaDevices;
    private MediaDeviceInfo? _selectedScanningMediaDevice;
    private bool _firstRenderComplete = false;
    private bool _showHadScanResultFlash = false;
    private bool _showHadScanErrorFlash = false;
    private bool _isModalVisable = false;
    private readonly TimeSpan _statusFlashDuration = TimeSpan.FromMilliseconds(600);
    private ElementReference? _webcamPreviewVideoElement;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (firstRender)
        {
            _ZXingMediaDevices = await JsRuntime.InvokeAsync<List<MediaDeviceInfo>>("ZXingListVideoInputDevices");
            if (_ZXingMediaDevices.Count > 0)
            {
                _selectedScanningMediaDevice = _ZXingMediaDevices[0];
                await EnableScanningWithMediaDevice(_selectedScanningMediaDevice);
            }
            _firstRenderComplete = true;
            StateHasChanged();
        }

        if (_webcamPreviewVideoElement != null && _selectedScanningMediaDevice != null)
        {
            await ShowWebcamPreviewOfMediaDeviceAsync(_selectedScanningMediaDevice);
        }
    }

    [JSInvokable]
    public async Task HandleScanResult(string scancode)
    {
        _showHadScanResultFlash = true;
        StateHasChanged();
        await OnZXingResult.InvokeAsync(scancode);
        await Task.Delay(_statusFlashDuration);
        _showHadScanResultFlash = false;
        StateHasChanged();
    }

    [JSInvokable]
    public async Task HandleScanError(string errorMessage)
    {
        _showHadScanErrorFlash = true;
        StateHasChanged();
        await Task.Delay(_statusFlashDuration);
        _showHadScanErrorFlash = false;
        StateHasChanged();
    }

    private async Task DisableScanning()
    {
        _selectedScanningMediaDevice = null;
        await JsRuntime.InvokeVoidAsync("ZXingResetCodeReader");
    }

    private async Task EnableScanningWithMediaDevice(MediaDeviceInfo mediaDeviceInfo)
    {
        await JsRuntime.InvokeVoidAsync(
            "ZXingRegisterOnDecodeListener",
            DotNetObjectReference.Create(this),
            nameof(HandleScanResult),
            nameof(HandleScanResult),
            mediaDeviceInfo.DeviceId,
            // this element sites outside of Blazor's control (in a hidden div)
            // to avoid re-creating the associated video element which causes some
            // serious issues.
            "hidden-webcam-scanner-video",
            3000
        );
        _selectedScanningMediaDevice = mediaDeviceInfo;
    }

    private async Task ShowWebcamPreviewOfMediaDeviceAsync(MediaDeviceInfo mediaDeviceInfo)
    {
        await JsRuntime.InvokeVoidAsync(
            "StreamMediaDeviceIntoVideoElement",
            _webcamPreviewVideoElement,
            _selectedScanningMediaDevice.DeviceId
        );
    }
}
