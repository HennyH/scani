@implements IDisposable
@inject IJSRuntime JsRuntime
@inject SynchronizedKioskState KioskState

<button type="button" class="btn btn-dark" @onclick="_ => _isModalVisable = true" style="justify-self: flex-end; margin-right: 1em;">
    <img src="@(_ok ? "/assets/images/okay.svg" : "/assets/images/error.svg")" style="width: 50px" />
    @if (_lastUpdated.HasValue)
    {
        <span style="margin-left: 0.5em">Last Updated @(_lastUpdated.Value.ToShortTimeString())</span>
    }
</button>

<Modal
    Title="Kiosk Status"
    IsVisable="_isModalVisable"
    OnModalDismissedFromJs="() => _isModalVisable = false"
>
    <Body>
        @if (_ok)
        {
            <p>Everything looks good - well done!</p>
        }
        else
        {
            <h5 style="text-align: center">Errors</h5>
        }

        @if (_studentErrors.Any())
        {
            <h6>Students</h6>
            <ul>
                @foreach (var error in _studentErrors)
                {
                    <li>@error.Message</li>
                }
            </ul>
        }

        @if (_equipmentErrors.Any())
        {
            <h6>Equipment</h6>
            <ul>
                @foreach (var error in _equipmentErrors)
                {
                    <li>@error.Message</li>
                }
            </ul>
        }

        @if (_loanErrors.Any())
        {
            <h6>Loans</h6>
            <ul>
                @foreach (var error in _loanErrors)
                {
                    <li>@error.Message</li>
                }
            </ul>
        }
    </Body>
    <Footer>
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
    </Footer>
</Modal>

@code {
    private List<KioskSheetReadError> _loanErrors = new List<KioskSheetReadError>();
    private List<KioskSheetReadError> _studentErrors = new List<KioskSheetReadError>();
    private List<KioskSheetReadError> _equipmentErrors = new List<KioskSheetReadError>();
    private bool _ok => !_loanErrors.Any() && !_studentErrors.Any() && !_equipmentErrors.Any();
    private DateTime? _lastUpdated = null;
    private bool _isModalVisable = false;

    protected override async Task OnInitializedAsync()
    {
        await KioskState.ReadStateAsync(async state =>
        {
            _loanErrors = state.LoanSheet?.Errors?.ToList() ?? new List<KioskSheetReadError>();
            _studentErrors = state.StudentsSheet?.Errors?.ToList() ?? new List<KioskSheetReadError>();
            _equipmentErrors = state.EquipmentSheet?.Errors?.ToList() ?? new List<KioskSheetReadError>();
            _lastUpdated = state.LastModified;
        });
        KioskState.StateChanged += HandleKioskStateChanged;
    }

    protected async void HandleKioskStateChanged()
    {
        await KioskState.ReadStateAsync(async state =>
        {
            _loanErrors = state.LoanSheet?.Errors?.ToList() ?? new List<KioskSheetReadError>();
            _studentErrors = state.StudentsSheet?.Errors?.ToList() ?? new List<KioskSheetReadError>();
            _equipmentErrors = state.EquipmentSheet?.Errors?.ToList() ?? new List<KioskSheetReadError>();
            _lastUpdated = state.LastModified;
            await InvokeAsync(StateHasChanged);
        });
    }

    public void Dispose()
    {
        KioskState.StateChanged -= HandleKioskStateChanged;
    }
}
